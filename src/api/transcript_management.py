"""
Transcript Management API for Phase 7C
Handles transcript listing, viewing, and download functionality
"""

import json
import logging
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional
from fastapi import APIRouter, HTTPException, Response
from fastapi.responses import JSONResponse, FileResponse
import sqlite3

logger = logging.getLogger(__name__)

def setup_transcript_routes(app, db):
    """Setup transcript management routes"""
    
    router = APIRouter(prefix="/api/transcript-browser", tags=["transcript-management"])
    
    @router.get("/hearings")
    async def get_hearing_transcripts():
        """Get list of hearing transcripts generated by the processing pipeline"""
        try:
            transcript_dir = Path('output/demo_transcription')
            transcripts = []
            
            if transcript_dir.exists():
                # Find all hearing transcript files
                for transcript_file in transcript_dir.glob("hearing_*_transcript.json"):
                    try:
                        with open(transcript_file, 'r') as f:
                            transcript_data = json.load(f)
                        
                        # Get additional hearing info from database if available
                        if transcript_data.get('hearing_id'):
                            hearing_info = get_hearing_info(db, transcript_data['hearing_id'])
                            if hearing_info:
                                transcript_data.update(hearing_info)
                        
                        transcript_data['file_path'] = str(transcript_file)
                        transcript_data['filename'] = transcript_file.name
                        transcript_data['file_size'] = transcript_file.stat().st_size
                        transcript_data['created_at'] = datetime.fromtimestamp(
                            transcript_file.stat().st_ctime
                        ).isoformat()
                        
                        transcripts.append(transcript_data)
                        
                    except Exception as e:
                        logger.error(f"Error reading transcript {transcript_file}: {e}")
                        continue
            
            # Sort by creation date, newest first
            transcripts.sort(key=lambda x: x.get('created_at', ''), reverse=True)
            
            return JSONResponse({
                "transcripts": transcripts,
                "total": len(transcripts),
                "transcript_dir": str(transcript_dir)
            })
            
        except Exception as e:
            logger.error(f"Error fetching hearing transcripts: {e}")
            raise HTTPException(status_code=500, detail=f"Failed to fetch transcripts: {str(e)}")
    
    @router.get("/content/{transcript_id}")
    async def get_transcript_content(transcript_id: str):
        """Get full content of a specific transcript"""
        try:
            transcript_dir = Path('output/demo_transcription')
            
            # Handle different transcript ID formats
            possible_files = [
                transcript_dir / f"hearing_{transcript_id}_transcript.json",
                transcript_dir / f"{transcript_id}.json",
                transcript_dir / transcript_id
            ]
            
            transcript_file = None
            for file_path in possible_files:
                if file_path.exists():
                    transcript_file = file_path
                    break
            
            if not transcript_file:
                raise HTTPException(status_code=404, detail=f"Transcript {transcript_id} not found")
            
            with open(transcript_file, 'r') as f:
                transcript_data = json.load(f)
            
            # Add file metadata
            stat = transcript_file.stat()
            transcript_data['file_metadata'] = {
                'filename': transcript_file.name,
                'file_size': stat.st_size,
                'created_at': datetime.fromtimestamp(stat.st_ctime).isoformat(),
                'modified_at': datetime.fromtimestamp(stat.st_mtime).isoformat()
            }
            
            return JSONResponse(transcript_data)
            
        except FileNotFoundError:
            raise HTTPException(status_code=404, detail=f"Transcript {transcript_id} not found")
        except json.JSONDecodeError:
            raise HTTPException(status_code=500, detail=f"Invalid transcript format for {transcript_id}")
        except Exception as e:
            logger.error(f"Error fetching transcript {transcript_id}: {e}")
            raise HTTPException(status_code=500, detail=f"Failed to fetch transcript: {str(e)}")
    
    @router.get("/download/{transcript_id}")
    async def download_transcript(transcript_id: str):
        """Download transcript file"""
        try:
            transcript_dir = Path('output/demo_transcription')
            
            possible_files = [
                transcript_dir / f"hearing_{transcript_id}_transcript.json",
                transcript_dir / f"{transcript_id}.json",
                transcript_dir / transcript_id
            ]
            
            transcript_file = None
            for file_path in possible_files:
                if file_path.exists():
                    transcript_file = file_path
                    break
            
            if not transcript_file:
                raise HTTPException(status_code=404, detail=f"Transcript {transcript_id} not found")
            
            return FileResponse(
                path=str(transcript_file),
                filename=transcript_file.name,
                media_type='application/json'
            )
            
        except Exception as e:
            logger.error(f"Error downloading transcript {transcript_id}: {e}")
            raise HTTPException(status_code=500, detail=f"Failed to download transcript: {str(e)}")
    
    @router.get("/stats")
    async def get_transcript_stats():
        """Get transcript statistics"""
        try:
            transcript_dir = Path('output/demo_transcription')
            
            if not transcript_dir.exists():
                return JSONResponse({
                    "total_transcripts": 0,
                    "total_size": 0,
                    "by_committee": {},
                    "by_date": {},
                    "average_confidence": 0
                })
            
            transcripts = []
            total_size = 0
            
            for transcript_file in transcript_dir.glob("*.json"):
                try:
                    with open(transcript_file, 'r') as f:
                        transcript_data = json.load(f)
                    
                    stat = transcript_file.stat()
                    total_size += stat.st_size
                    
                    transcript_data['file_size'] = stat.st_size
                    transcript_data['created_date'] = datetime.fromtimestamp(
                        stat.st_ctime
                    ).strftime('%Y-%m-%d')
                    
                    transcripts.append(transcript_data)
                    
                except Exception as e:
                    logger.error(f"Error reading transcript {transcript_file}: {e}")
                    continue
            
            # Calculate statistics
            by_committee = {}
            by_date = {}
            total_confidence = 0
            confidence_count = 0
            
            for transcript in transcripts:
                committee = transcript.get('committee', 'Unknown')
                date = transcript.get('created_date', 'Unknown')
                confidence = transcript.get('confidence')
                
                by_committee[committee] = by_committee.get(committee, 0) + 1
                by_date[date] = by_date.get(date, 0) + 1
                
                if confidence is not None:
                    total_confidence += confidence
                    confidence_count += 1
            
            return JSONResponse({
                "total_transcripts": len(transcripts),
                "total_size": total_size,
                "by_committee": by_committee,
                "by_date": by_date,
                "average_confidence": round(total_confidence / confidence_count, 3) if confidence_count > 0 else 0
            })
            
        except Exception as e:
            logger.error(f"Error calculating transcript stats: {e}")
            raise HTTPException(status_code=500, detail=f"Failed to calculate stats: {str(e)}")
    
    # Add routes to the app
    app.include_router(router)
    
    logger.info("Transcript management routes configured")

def get_hearing_info(db, hearing_id: int) -> Optional[Dict[str, Any]]:
    """Get additional hearing information from database"""
    try:
        cursor = db.connection.execute("""
            SELECT hearing_title, committee_code, hearing_date, hearing_type, 
                   status, processing_stage
            FROM hearings_unified 
            WHERE id = ?
        """, (hearing_id,))
        
        row = cursor.fetchone()
        if row:
            return {
                'hearing_title': row[0],
                'committee_code': row[1], 
                'hearing_date': row[2],
                'hearing_type': row[3],
                'status': row[4],
                'processing_stage': row[5]
            }
    except Exception as e:
        logger.error(f"Error fetching hearing info for {hearing_id}: {e}")
    
    return None